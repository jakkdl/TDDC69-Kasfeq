\begin{center}
  \textbf{\Huge Slutinlämning}\\[1cm]
\end{center}
\section{Implementationsbeskrivning}
Den här sektionen använder ni för att beskriva hur projektet är strukturerat och implementerat. Algoritmer och övergripande design passar också in i det här kapitlet (bilder, flödesdiagram, osv. kan vara användbart). Skapa gärna egna delkapitel för enskilda delar, om det underlättar.\\ 
\subsection{Milstolpar}
Ange för varje milstolpe om ni har genomfört den helt, delvis eller inte alls.  (Detta är främst till för att labbhandledaren ska veta vilken funktionalitet man måste ”leta efter” i koden.  Själva bedömningen beror inte på antalet milstolpar i sig.)\\
\subsection{Dokumentation för programkod}
Programkod behöver dokumenteras för att man ska förstå hur den fungerar och hur allt hänger ihop.  Vissa typer av dokumentation är direkt relaterad till ett enda fält, en enda metod eller en enda klass och placeras då lämpligast vid fältet, metoden eller klassen i en Javadoc-kommentar, inte här.  Då är det både enklare att hitta dokumentationen och större chans att den faktiskt uppdateras när det sker ändringar.  Annan dokumentation är mer övergripande och placeras då här.  Det kan gälla till exempel:\\
Övergripande programstruktur, t.ex. att man har implementerat ett spel som styrs av timer-tick n gånger per sekund där man vid varje sådant tick först tar hand om input och gör eventuella förflyttningar för objekt av typ X, Y och Z, därefter kontrollerar kollisioner vilket sker med hjälp av klass W, och till slut uppdaterar skärmen.\\
\vspace{11pt}
Översikter över relaterade klasser och hur de hänger ihop.  Här kan det ofta vara bra att använda UML-diagram för att illustrera – men fundera då först på vilka grupper av klasser det är ni vill beskriva, och skapa sedan ett UML-diagram för varje grupp av klasser (det är sällan särskilt användbart att lägga in hela projektet i ett enda gigantiskt diagram).  Skriv sedan en textbeskrivning av vad det är ni illustrerar med UML-diagrammet.  Texten är den huvudsakliga dokumentationen medan UML-diagrammet hjälper läsaren att förstå texten och få en översikt.  IDEA kan hjälpa till att göra klassdiagram som ni sedan kan klippa och klistra in i dokumentet.\\
\vspace{11pt}
Labbhandledaren och examinatorn kommer bland annat att använda den här dokumentationen för att förstå programmet vid bedömningen.  Ni kan också tänka er att ni själva ska vidareutveckla projektet efter att en annan grupp har utvecklat grunden.  Vad skulle ni själva vilja veta i det läget?  Om viktig information saknas kan ni få komplettera.\\
När ni pratar om klasser och metoder ska deras namn anges tydligt (inte bara ”vår timerklass” eller ”utritningsmetoden”).\\
Framhäv gärna det ni själva tycker är bra lösningar eller annat som handledaren borde titta på vid bedömningen.\\
Se även sidan om krav på programkod på webben.\\
Vi räknar med att de flesta projekt behöver runt 2-5 sidor för det här avsnittet.\\
\subsection{Användning av fritt material}
Skriv ner vilka klassbibliotek och vilket annat fritt material ni har använt utöver det som ingår i Java 7, eller ange uttryckligen att ni inte har använt något.\\
\subsection{Användning av designmönster}
Beskriv tydligt i numrerad lista vilka designmönster som använts i implementationen, vad ni åstadkommer genom att använda just de designmönstren i just ert projekt (vad var bra med att använda det?), och hur designmönstret har realiserats i praktiken, t.ex. vilka klasser som är inblandade och vad de motsvarar i designmönstrets terminologi (”Klasserna X och Y är våra konkreta strategier för den här användningen av strategimönstret”).\\
Beskrivning från websidan:\\
\begin{tabular}{| p{11cm} |}
    \hline
    För varje betygsnivå måste ett visst antal designmönster implementeras och användas, för att ni ska visa att ni behärskar dem. Designmönstren måste användas på ett lämpligt sätt, dvs. varje mönster måste användas för att implementera funktionalitet där det mönstret faktiskt passar. Detta kan till viss del påverka vilken funktionalitet ni implementerar. \\ \hline
    Designmönstren ska implementeras från grunden. Om ni använder en Comparator som argument till Javas sorteringsmetoder räknas det inte som att ni har implementerat Strategy-mönstret. \\ \hline
    Alla designmönster från Design Patterns av Gamma, Helm, Johnson och Vlissides är godkända. Fråga examinatorn om ni vill tillgodoräkna er andra mönster och ge en referens till det mönster ni undrar över. \\ \hline
    Beskriv noggrant var och hur designmönstret är implementerat (vilka klasser/metoder i er kod), varför ni valde att använda detta mönster snarare än något annat mönster eller en ad-hoc-metod, samt en kortare förklaring av designmönstrets för- och nackdelar i denna specifika situation. \\ \hline
\end{tabular}\\\vspace{11pt}
1. X\ldots\\
Detta mönster använder vi\ldots\\
2. Y\ldots\\
Detta mönster använder vi\ldots\\
3. Z\ldots\\
\ldots\\
\subsection{Användning av objektorientering}
För varje betygsnivå måste ni peka ut ett visst antal lösningar ni har gjort där ni använder objektorienterade "finesser" som t.ex. polymorfism.  Diskutera hur man kunde ha löst detta utan objektorientering och kontrastera de lösningarna mot varandra. \\
Beskrivning från websidan:\\
\begin{tabular}{| p{11cm} |}
    \hline
    För varje betygsnivå måste ni peka ut ett visst antal lösningar ni har gjort där ni använder objektorienterade "finesser" som t.ex. polymorfism, och diskutera kortfattat (några meningar) hur man kunde ha löst detta utan objektorientering. \\ \hline
    Tänk på att det verkligen ska gälla finesser som är "unika" för objektorientering. Enum-konstanter finns t.ex. i olika former i icke-OO-språk som C. Serialisering av datastrukturer finns också i icke-OO-språk. \\ \hline
\end{tabular}\\\vspace{11pt}
1. \ldots\\
2. \ldots\\
3. \ldots\\
\subsection{Motiverade designbeslut med alternativ}
Här anger ni (numrerade) motiverade designbeslut enligt betygskraven på webben.  Anledningen är både att ni ska visa oss hur ni har tänkt och att ni själva ska fundera och reflektera över era val.\\
Sådant som ska göras enligt projektkraven är inte (gruppens) designbeslut, t.ex. att de flesta fält ska vara privata.  De alternativa lösningarna som ni anger ska vara någorlunda rimliga (det är normalt inte ett designbeslut att dela upp koden i flera klasser eftersom alternativet för ett projekt av den här storleken skulle vara absurt).\\
Beskrivning från websidan:\\
\begin{tabular}{| p{11cm} |}
    \hline
    För varje betygsnivå måste ni beskriva ett visst antal designbeslut ni har tagit, med särskild tonvikt på användning av objektorientering. För varje designbeslut ska ni beskriva vad ni ville åstadkomma, hur ni gjorde, minst en annan alternativ lösning, och varför den lösning ni gjorde var bättre än alternativet. (I vissa fall kanske ni inser att den lösning ni valde var sämre än alternativet – beskriv då varför.) Detta ska vara andra lösningar än de som kommer från punkten ovan. \\ \hline
    Designbesluten ska vara på rimligt hög "objektorienterad nivå", dvs. inte varför ni valde att använda "int" istället för "long" för ett visst fält... Använde ni en enda lyssnarklass för knapparna i ett GUI, eller flera? Använder ni fabriker, prototyper eller vanliga konstruktorer för att skapa brickor i Breakout? \\ \hline
\end{tabular}\\\vspace{11pt}
1. \ldots \\
2. \ldots \\
3. \ldots \\
4. \ldots \\
5. \ldots \\
6. \ldots \\
7. \ldots \\
8. \ldots \\
\section{Användarmanual}
När ni har implementerat ett program krävs det också en manual som förklarar hur programmet fungerar. Ni ska beskriva programmet tillräckligt mycket för att en labbhandledare själv ska kunna starta det, testa det och förstå hur det fungerar. \\
Inkludera flera (minst 3) skärmdumpar som visar hur programmet ser ut!\\
\section{Betygsambitioner}
Ange här vilket betyg ni siktar på i ert projekt.  Se sedan till att ni har följt de mätbara kraven för detta betyg och att detta finns dokumenterat i projektbeskrivningen ovan.\\
\section{Utvärdering och erfarenheter}
Detta avsnitt är en väldigt viktig del av projektspecifikationen. Här ska ni tänka tillbaka och utvärdera projektet (något som man alltid bör göra efter ett projekt). Som en hjälp på vägen kan ni utgå från följande frågeställningar:\\
Vad gick bra? Mindre bra?\\
Lade ni ned för mycket/lite tid?\\
Var arbetsfördelningen jämn? Om inte: Vad hade ni kunnat göra för att förbättra den?\\
Har ni haft någon nytta av projektbeskrivningen? Vad har varit mest användbart med den? Minst?\\
Har arbetet fungerat som ni tänkt er? Har ni följt "arbetsmetodiken"? Något som skiljer sig? Till det bättre? Till det sämre?\\
Vad har varit mest problematiskt, om man utesluter den programmeringstekniska delen? Alltså saker runt omkring, som att hitta ledig tid eller plats att vara på.\\
Vad har ni lärt er så här långt som kan vara bra att ta med till era egna kommande kurser/projekt?\\
Vilka tips skulle ni vilja ge till studenter i nästa års kurs?\\
Har ni saknat något i kursen som hade underlättat projektet?\\
\vspace{11pt}
Vi använder detta för att utveckla och förbättra kursen till nästa år.  Vissa delar som är användbara som tips till andra studenter kan komma att citeras (givetvis helt anonymt!) under föreläsningar eller på websidor.\\
(Glöm inte att exportera till PDF-format innan ni skickar in!)\\
